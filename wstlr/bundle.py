#!/usr/bin/env python
"""Handle bundles from within the wstlr framework. This includes
   parsing the bundles generated by whistle itself and potentially
   prepping those bundles for loading into a FHIR server as 
   transaction bundles

   Resource Consumers - These are functors which accept two parameters,
   a FHIR resource and a corresponding group name. It is up to the 
   consumer to determine what to do with each resource passed 
   (if anything at all).    

   example: 
   
def ConsumeResource(group_name, resource):
    # Do stuff here
"""

import json
from enum import Enum
from copy import deepcopy
from argparse import ArgumentParser, FileType
from wstlr import get_host_config
import sys
from pathlib import Path

import pdb


def ParseBundle(bundle_file, resource_consumers):
    """Iterate over each resource inside the bundle and pass those
    resources to each resource_consumers. """

    content = json.load(bundle_file)

    # We expect there to be at least one key that points
    # to an array of resource records. If there are more
    # that is fine. Each will be processed independently
    # and the key will be passed as the "resource_group"
    for resource_group in content.keys():
        for resource in content[resource_group]:
            #pdb.set_trace()
            for consumer in resource_consumers:
                consumer(resource_group, resource)

class RequestType(Enum):
    PUT = 1
    POST = 2

class Bundle:
    """Update the bundle created by whistle to be a valid transaction bundle"""
    def __init__(self, filename, bundle_id, target_service_url, request_type=RequestType.PUT):
        self.filename = filename
        self.write_comma = False
        self.bundle = open(self.filename, 'wt')
        self.request_type = request_type
        self.target_service_url = target_service_url
        self.verb = "PUT"
        if request_type == RequestType.POST:
            self.verb="POST"
        self.bundle.write("""{
    "resourceType": "Bundle",
    "id": \"""" + bundle_id + """\",
    "type": "transaction",
    "entry": [
""")

    def consume_resource(self, group, resource):
        response = deepcopy(resource)
        if self.bundle:
            # For now, let's just skip the ID so that it works in a more general sense

            if 'resourceType' not in resource or 'id' not in resource:
                pass
                #print(resource.keys())
                #pdb.set_trace()

            if self.request_type == RequestType.PUT:
                id = resource['id']
                destination = f"{resource['resourceType']}/{resource['id']}"
            else:
                destination = f"{resource['resourceType']}" 
                id = resource['identifier'][0]['value']
                
            if self.write_comma: 
                self.bundle.write(",")
            self.write_comma = True
            #pdb.set_trace()
            resource_data = json.dumps(resource)
            full_url = f"""{self.target_service_url}/{resource['resourceType']}/{id}"""
            self.bundle.write("""    {
      "fullUrl": \"""" + full_url + """\",
      "resource": """ + resource_data + """,
      "request": {
          "method": \"""" + self.verb + """\",
          "url": \"""" + destination + """\"
      }
    }""")
        return response

    def close_bundle(self):
        if self.bundle:
            self.bundle.write("""
  ]
}""")
            self.bundle.close()        


def exec():
    host_config = get_host_config()
    # Just capture the available environments to let the user
    # make the selection at runtime
    env_options = sorted(host_config.keys())
    
    parser = ArgumentParser(
        description="Convert Whistle generated bundle into a proper transaction bundle."
    )
    parser.add_argument(
        "-e",
        "--env",
        choices=env_options,
        default=env_options[0],
        help=f"Remote configuration to be used to access the FHIR server",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="output/whistle-output/",
        help="Directory for transaction bundle to be written (file name will be based on source filename)"
    )
    parser.add_argument(
        "filename",
        nargs="+",
        type=FileType('rt'),
        help="JSON file from whistle output"
    )
    args = parser.parse_args(sys.argv[1:])
    
    for fn in args.filename:
        fname = f"{Path(fn.name).stem}-transaction.json"
        outfilename = Path(args.output) / fname 

        bundle = Bundle(str(outfilename), fname, args.env)
        ParseBundle(fn, [bundle.consume_resource])